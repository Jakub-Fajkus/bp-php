%=========================================================================
% (c) Michal Bidlo, Bohuslav Křena, 2008

\chapter{Úvod}
V oblasti robotiky je velmi důležíté mít možnost vytvářet rychle a levně prototypy.
K tomuto účelu je při návrhu fyzické struktury robota výhodné použít počítačové modely a simulace.
Je výhodné mít i možnost rychle prototypovat řízení robota.
Řízení robota je ovšem možné realizovat mnoha způsoby, např. umělými neuronovými sítěmi, konenčnými automaty nebo i programy v nějakém imperativním jazyce.
V závislosti na vybrané metodě řízení robota jsou k dispozici různé alogritmy a automatizované nástroje pro nalezení konfigurace zvoleného způsobu řízení, která bude mít za následek požadované chování robota.
Touto konfigurací může být např. váhy neuronové sítě, definice konečného automatu nebo sekvence příkazů imperativního jazyka.
Právě řízením robota programy napsanými v imperativním jazyce (byť jednoduchém) se zabývá tato práce, ve které jsou použity evoluční algoritmy pro automatizované hledání vhodného řízení robota.

Cílem této práce je návrh a implementace nástroje pro automatizované hledání vhodného kontroléru robotického modelu pro průchod prostorem po dané trajektorii.
Pro návrh vhodného programu je použita technika zjednodušeného Lineárního Genetického Programování.
Pro simulaci pohybu robotického modelu byl použit simulátor Mujoco.
Účinnost softwarového řízení je experimentálně doložena.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\chapter{Evoluční algoritmy}
\todo{informace o tom, ze jsem to cele opsal z knizky!}

\section{Koncept evolunčích algoritmů}

Evoluční algoritmy (EA) jsou inspirovány přírodními evolučními procesy a Darwinovou teorií evoluce.
EA se využívají ke stochastickému prohledávání stavového prostoru.
EA, narozdíl od jiných metod, pracují s celou populací kandidátních řešení (jedinců), které se vyvíjí paralelně.
Každý jedinec v populaci v sobě nese zakódovanou informaci o konktrétním řešení, kterou nazýváme genotyp.
Genotyp se poté dekóduje na fenotyp, který už reprezentuje řešení daného problému.

Myšlenku EA můžeme popsat následovně.
Máme populaci jedinců, kteří jsou všichni umístěni ve společném prostředí, ve kterém soutěží o zdroje.
To má za následek přirozený výběr jedinců, který se projevuje tak, že horší jedinci mají menší pravděpodobnost reprodukce, než-li ti lepší.
Tímto se přirozeně zvyšuje kvalita populace.
Reprodukce probíhá dvojím způsobem, a to křížením a mutací.
Křížení pracuje se dvěmi rodiči a má za následek vytvoření dvou potomků, kteří vznikají kombinací genotypu obou rodičů.
Mutace pracuje nad jedním rodičem a produkuje jednoho potomka, který má narozdíl od svého ročiče lehce pozměněný genotyp.

Činnost obecného EA můžeme vidět na algoritmu \ref{alg:EA_alg}:


\begin{algorithm}[H]
    inicializuj populaci náhodně vygenerovanými jedinci\;
    vyhodnoť všechny jedince\;
    \While{(není splněna ukončující podmínka)}{
        vyber rodiče\;
        aplikuj křížení na dvojice rodičů\;
        mutuj potomky\;
        vyhodnoť kvalitu potomků\;
        vyber jedince do další generace\;
    }
    \caption{Obecný evoluční algoritmus}
    \label{alg:EA_alg}
\end{algorithm}

\subsection{Reprezentace}
Při návrhu řešení problému je často nutné abstrahovat reálný svět tak, aby jsme vytvořili prostředí, ve terém budou existovat kandidátní řešení a ve kterém budou tato řešení vyhodnocována.
Kandidátní řešení problému nazýváme fenotypy.
Zakódované fenotypy nazýváme genotypy.
Termín reprezentace se používá ve dvou kontextech.
V prvním kontextu specifikuje mapování z fenotypu na genotyp a je synonymem pro kódování.
V druhé kontextu označuje spíše strukturu prostoru genotypů.

\subsection{Fitness funkce}
Úlohou fitnes funkce je reprezentování požadavků, které by populace měla splňovat.
Tvoří základ pro funkci selekčních operátorů.
Můžeme mluvit o zobrazení z jedince v prostoru genotypů na reálné, nebo celé, číslo.
Z technického hlediska se jedná o funkci, která měří míru kvality genotypu a přiřazuje mu tzv. fitness.
Výpočet fitness funkce zahrnuje dekódování genotypu na fenotyp a následné vyhodnocení fenotypu, jako kandidátního řešení pro daný problém.

\subsection{Populace}
Úlohou populace je obsahovat množinu kandidátních řešení --- jedná se o multimnožinu jedinců.
Populace je struktura, která podléhá evoluci, zatímco jedinci jsou statické struktury.
Definice populace se může omezit pouze na její velikost, ale existují i specializované evoluční algoritmy, které pracují i s rozložením jedinců v prostoru.


\subsection{Selekce}
Operátor selekce slouží k výběru rodičů pro křížení na základě jejich kvality.
Tento operátor je nejšastěji založen na náhodě a to tak, že kvalitnější řešení jsou vybárána s větší pravděpodností.
Změnou parametrů selekce nastavujeme tzv. selekční tlak, který ovlivňuje, do jaké míry jsou upřednostňováni lepší jedinci.

Za typické představitele selekce můžeme považovat selekci turnajem a ruletovou selekci.
\todo{vytahnout z nejake ceske knizky}

Selekce turnajem, narozdíl od ruletové selekce nevyžaduje znalost celé populace a přepočítávání fitness hodnot.
Selekce turnajem ani nevyžaduje, aby vyhodnocení fitness funkcí bylo kvantifikované, ale pro jeho funkci stačí, aby byla mezi jedinci definována operace uspořádání.
Díky toho je tato metoda nenáročná na implementaci a na výpočetní čas.
Základní alogoritmus selekce turnajem můžeme vidět na algoritmu \ref{alg:EA_turnaj}.

\begin{algorithm}[H]
    // Chceme vytvořit mating pool velikosti $\lambda$ jedinců\;
    \While{(dokud mating pool neobsahuje $\lambda$ jedinců)}{
        Náhodně vyber $k$ jedinců\;
        Porovnej mezi sebou těchto $k$ jedinců a vyber z nich nejlepšího jedince $i$\;
        Vlož jedince $i$ do mating pool
    }
    \caption{Selekce turnajem}
    \label{alg:EA_turnaj}
\end{algorithm}

Úpravou parametru $k$ se nastavuje selekční tlak --- čím větší je parametr, tím více jedinců je vybráno pro porovnání a to má za následek vyšší selekční tlak.

\subsection{Křížení}
Operátor křížení slouží ke spojení částí genotypů rodičů a tím dochází k vytvoření nových jedinců.
Operátor je většinou aplikován pouze s určitou pravděpodobností $p_r$.
Nejčastěji se používá křížení pracující se dvěmi rodiči.
Výběr, jeké části ze kterého rodiče budou vybrány, je založen na náhodě.
Myšlenka za použitím křížení je následující.
Zkombinováním rodičů, kteří mají odlišné, ale vhodné vlasnosti, může vzniknout jedinec, který tyto vlastnosti v sobě kombinuje a dosahuje tak vyšší kvality.

Jako představitele si můžeme uvést jednobodové a uniformní křížení.

Jednobodové křížení bylo původně představeno J. H. Hollandem v \todo{220} a jeho funkce je následující.
Vygeneruje se náhodné číslo $r$ z intervalu \todo{latex!} <1,l-1>, kde l je délka genomu.
Poté se genomy rozdelí v tomto bodě $r$ na počáteční a koncovou část a noví jedinci vznikají záměnou těchto koncových částí, viz \todo{obrazek}.

Uniformní křížení bylo představeno v \todo{422} a pracuje následovně.
Pro každý gen se vygeneruje náhodné číslo $r$ z rovnoměrného rozložení na intervalu <0,1>.
Číslo $r$ se poté porovná s parametrem $p$, který bývá obvykle roven 0.5, a pokud je $r < p$, tak se použije gen z prvního rodiče, jinak ze druhého.
Druhý potomek je vytvořen z genů, které nebyly vybrány do prvního potomka, viz \todo{obrazek}.

\subsection{Mutace}
Operátor mutace se aplikuje na jendoho rodiče a jeho výsledkem je jeden potomek.
Cílem mutace je provést malou změnu genotypu.
Operátor je většinou aplikován pouze s určitou pravděpodobností $p_m$ a jeho implementace je závislá na použité reprezentaci.


Např. pro reprezentace využívající celá čísla, existují 2 záladní přístupy, které mutují každý gen s pravděpodobností $p_m$.
\todo{Random resetting} je způsob, při kterém je pro gen náhodně vygenerována nová hodnota z množiny všech možných hodnot.
Tato varianta je vhodná, pokud mezi hodnotami neexistuje relace uspořádání.
\todo{Creep mutation} je způsob, při kterém se k hodnotě genu přičte nebo odečte náhodně vygenerované malé číslo.
Tato varianta je vhodná, jsou-li hodnoty genomu např. parametry nějakého systému.

\todo{ukoncovaci podminka!}

\section{Genetické programování}
\todo{zalozeno na koze}
Genetické programování (GP) se zabývá evolucí programu, který je reprezenotván stromovou strukturou.
Programy v GP jsou složeny z funkcí, které ve stromové struktuře odpovídají uzlům, a terminálů, které odpovídají listům.

Vyvíjené programy jsou typicky vyhodnocovány nad sadou vstupů, tzv. fitness cases, u kterých jsou známy požadované výstupy programu.
Výsledná fitness programu se pak může počítat jako suma nebo průměr výsledků z každého "fitness case".

V GA je nejdůležitějším operátorem křížení.
Křížení pracuje na základě výměny náhodně vybraných podstromů z rodičů.
Toto křžení se skládá z několika kroků.
Prvním krokem je výběr rodičů.
Druhý krok je zvolení náhodného uzlu v každém z rodičů.
Tento uzel bude kořenový uzel pro podstromy, které se budou později mezi rodiči vyměňovat.
Třetím krokem je vyjmutí podstromu z obou rodičů, jejichž kořenovým uzlem je uzel, který byl vybrán v předchozím kroku.
Následuje vytvoření obou potomků.
První potomek vznikne tak, že se do stromu prvního rodiče, do místa dříve vybraného uzlu, vloží podstrom z druhého rodiče.
Druhý jedinec vzniká obdobným způsobem, viz. obrázek \ref{fig:GP_krizeni}.

\begin{figure}[h]
    \centering
    {\includegraphics[width=30em]{obrazky-figures/gp_krizeni.pdf}}
    \caption{
    Křížení v GP.
    Na tomto obrázku je zachycena situace, kdy je v každém z rodičů A a B náhodně vybrán uzel(vyznačen dvojitě).
    Tyto uzly a jejich podstromy jsou poté zaměněny a vznikají tak potomci C a D.
    }
    \label{fig:GP_krizeni}
\end{figure}

Velikost programu, definována jako výška stromu, je omezena aby se předoslo velmi velkým programům.
Pokud by potomek po křížení přesáhl tuto velikost, nebude vložen do nové generace - místo něj se do nové generace reprodukuje jeden z jeho rodičů.



\section{Lineární genetické programování}
V této práci se používá přístup inspirovaný LGP, které si stručně popíšeme dále.

LGP je varianta GP, která vyvíjí programy složené z instrukcí imperativního jazyka nebo strojového kódu, narozdíl od výrazů funkcionálního jazyka.
Instrukce mají parametry, kterými mohou být buď konstanty nebo proměnné, které se nazývají registry.
Tyto registry dělíme na vstupní, výstupní, pracovní a registry, obsahující konstanty.

Program v LGP v průběhu svého vykonávání čte hodnoty z registrů a modifikuje je za použití instrukcí.
Tímto provádí transformaci hodnot ze vstupních registrů do výstupních registrů.

LGP zahrnuje koncepty pro větvení, iteraci a vytváření podprogramů.
Tyto koncepty ale nejsou v této práci využity.
Namísto toho se z LGP využívá základní myšlenka lineární struktury programu složeného z instrukci a práce s registry.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Zkoumání pohyblivých objektů}
\todo{3. Zkoumani pohyblivych objektu (zakladni myslenky shrnte s inspiraci v
clancich G. Hornbyho. ~3 strany. Zamerte se v zaverecne podsekci na
popis objektu, ktere budete mit v BP.}
\todo{precist clanek o evolucni robotice, hlavni myslenky prenest zde a vymezit tuto praci, ze tam uplne napatri, ale patri spise do AI - cca 1 strana?}



Tato práce a pohyblivé struktury, se kterými se pracuje, je inspirována dizertací G. Hornbyho.
G. Hornby ve své práci využíval generativné reprezentace pro development struktury i kontroléru robotů.
[todo obrazky nekterych robotu hornbyho ]
Kotroléry byly realizovány pomocí oscilátorů nebo neuronových sítí.

Wolff a Wahde použili LGP pro návrh kontroléru modelu humanoidního robota, který měl v simulovaném prostředí chodit a následovat zvukové signály.

[todo: overit ] Wolff a Wahle použili LGP s čísly s plovoucí řádovou čárkou, aritmetické, matematický instrukce a větvení.
[todo: overit ] Jejich kontrolér měl informace o natočení všech kloubů modelu a na základě těchto informací programy řídily model robota.




Níže si popíšeme dva modely robotů, se kterými byly provedeny experimenty.
První model, zvaný trojnožka, je vidět na obrázku XXX.
Robot má 3 nohy, každá z nich je spojena s jádrem robota kloubem, který se otáčí v jedné ose.
Rozsah pohybu těchto kloubů je omezen na 50 stupňů.
Model robota má v horní části v místě kloubů umístěny kontaktní body.
Tyto body slouží k detekci převrácení robota (kolizi ze zemí).

%\caption{
Model robota zvaný trojnožka.
Tento model je složen z jádra robota (modře) a 3 nohou (hnědě).
Každá z nohou je s jádrem spojena kloubem, který se otáčí pouze v jedné ose a je umístěn pod fialovou koulí.
Tyto fialové koule slouží k detekci převrácení robota.
Ve středu robota je bod zvaný hlava (červeně).
%}

Druhý robot, zvaný mravenec, je vidět na obrázku XXX.
Robot má 3 páry nohou, které jsou všechny připojeny k tělu robota.
Rozsah pohybu kloubů, které rotují kolem horizontální osy a spojují tělo robota s jeho nohou, je omezen na 100 stupňů.
Rozsah kloubů, které rotují kolem svislé osy a spojují dvě části nohy, je omezen na 65 stupňů.
Robot má v přední části kontaktní bod, taktéž pro zjišťování kolizí se zemí.

%\caption{
Model robota zvaný mravenec.
Tento model je složen z těla robota (modře) a 6-ti nohou (hnědě).
V přední části robota je bod zvaný hlava (červeně).
Každá noha je složena ze dvou pevných částí a jedoho kloubu.
Tento kloub se pohybuje pouze ve svislé ose, tj. může zvedat a snižovat robota.
Celá noha je připojena k tělu robota kloubem, který se pohybuje horizontálně, tj. slouží k odrážení.
%}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Evoluční návrh pohyblivých objektů}
\todo{4. Evolucni navrh pohyblivych objektu - HLAVNI KAPITOLA BP - zde
popisteje podrobne vlastni techniky, ktere pro EVOLUCI pouzivate. Fakta
o EA budou vychazet k kapitoly 2.}


Cpp cast
- popis interpretu
- popis jazyka
- podprogramy
- input hodnoty (koste)
- prevod outputu na silu v kloubech ??
- spojeni interpretu a simulatoru
- pocitani fitness!

php cast
- popis evoluce
- algoritmus
- genotyp
- instance EA - populace, delka, selekce, crossover, mutace

spojeni php a cpp

\section{Simulace}

V simulátoru Mujoco je vytvořena scéna, která obsahuje model robota a množinu referenčních bodů, které svým pořadím a umístěním ve scéně definují trajektorii, kterou má robot následovat.


\section{Interpret}

Program, který řídí model robota, je vykonáván v interpretu.
Interpret obsahuje paměťová místa, kterým se říká registry, které se dělí na: vstupní, výstupní a konstantní.
Každý registr je indetifikovaný unikátním číslem, které se navýzá index, a může obsahovat celočíselné hodnoty v rozsahu od -5 do 5.
Počty registrů jsou následující: 11 konstatních registrů s hodnotami od -5 do 5, 2 vstupní registry, a 3 nebo 12 výstupních registrů (pro každý kloub modelu jeden registr).
Interpret vykonává program, který je složen z instrukcí.

Je zde použit jen jeden druh instrukce, a to instukce s názvem COPY.
Tato instrukce má 2 parametry: zdrojový registr a cílový registr.
Výsledkem této instrukce je zkopírování hodnoty ze vstupního, nebo konstatního, registru do výstupního registru.

\section{Vykonávání programu}

V průběhu simulace je vykonáván program, který čte hodnoty ze vstupních registrů, které obsahují informaci o směru k dalšímu referenčnímu bodu, a zapisuje hodnoty do výstupních registrů, které se převádí na sílu, která je aplikována v jednotlivých kloubech.

\section{Podprogramy}

Každý program, který reprezentuje kandidátní řešení, je pro vykonávání v průběhu simulace rozdělen na 3 podprogramy.
Tyto podprogramy se nazývají init, main a event.

Podprogram init se vykoná pouze na začátku simulace a všechny instrukce jsou provedeny v nulovém čase a poté je po 1 sekundě spuštěn podprogram main.
Účelem podprogramu init je nastavení počátečního natočení kloubů modelu.

Podprogram main je v průběhu simulace vykonáván v nekonečné smyčce.
Instrukce v tomto podprogramu se nevykonají všechny v nulovém čase, ale vyonávají se s periodou 0.3 sekundy.
Jedná se o nejdelší a nejdůležitější podprogram.

Podprogram event se vykoná v situaci, kdy se model přiblíží do určené vzdálenosti od referenčního bodu, avšak pro každý referenční bod pouze jednou.
Stejně jako u podprogramu init jsou instrukce provedeny v nulovém čase a poté je po 1 sekundě spuštěn podprogram main.
Účelem podprogramu event je změna natočení kloubů modelu jako příprava k pohybu k následujícímu referečnímu bodu.

\section{Input hodnoty}

Hodnoty, které se ukládájí do vstupních registrů, vychází z informace o směru k následujícímu referenčnímu bodu.
Informace o směru je opět vyjádřena číslem od -5 do 5 a vypočítává se následujícím mechanismem.

Prostor kolem modelu je rozdělen na několik kruhových výsečí, kde každá výseč je ohodnocena číslem od -5 do 5, viz obr. KOŠTĚ.
Informace o směru je rovna ohodnocení výseče, ve které se nachází další referenční bod.
Tato informace je v nezměněné podobě vložena do prvního vstupního registru.
Do druhého registru je vložena hodnota s převráceným znaménkem.

Na obrázku KOŠTĚ můžeme vidět situaci, kdy model (na obrázku dole) směřuje směrem nahoru a další referenční bod (modře) se nachází ve výseči ohodnocené číslem 2.
Hodnoty vstupních registrů budou tedy čísla 2 a -2.

\section{Výstupní registry}

Každý z výstupních registrů interpretu odpovídá jednomu kloubu modelu.
Hodnoty z výstupního registru jsou z interpretu čteny a převádí se na ovládací signály, které se předávají simulátoru.
Hodnota (ovládací signál) v sobě obsahuje dvě informace.
První z nich je dána znaménkem a určuje, kterým směrem bude aplikována síla v kloubu.
Druhá informace je dána velikostí hodnoty a určuje velikost této síly.

\section{Simulátor}
Simulátor Mujoco funguje jako TODOOOO dynamicky linkovana knihovna napsana v jazyce C.
Tato knihovna poskytuje řadu funkcí, které umožňují řídít běh simulace.
V uživatelkém programu je tedy nutné z poskytnutých funkcí sestavit algoritmus spojité simulace (ukázkové uživtelské programy jsou součástí distribuce).
Uživatel má plnou kontrolu nad během simulace, a to tím, že volá knihovní funkci TODOO mj\_step(), která v simulaci pokročí definovaným časem.
Ve smyčce algoritmu spojité simulace jsou vloženy funkce, které ze simulátory čtou pozice jendotlivých obejktů, běh interpretu, výpočet fitness funkce a mapování výstupních hodnot z interpretu na ovládací signály.
Ve zjednodušené formě je program znázorněn na OBRÁZKU.






4.1 Evoluce programu
Pro vyse uvedene case studies doporucuji provest experimenty vzdy s
trojnozkou a mravencem na spirale.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\chapter{Závěr}
Závěrečná kapitola obsahuje zhodnocení dosažených výsledků se zvlášť vyznačeným vlastním přínosem studenta. Povinně se zde objeví i zhodnocení z pohledu dalšího vývoje projektu, student uvede náměty vycházející ze zkušeností s řešeným projektem a uvede rovněž návaznosti na právě dokončené projekty.

%=========================================================================
