%=========================================================================
% (c) Michal Bidlo, Bohuslav Křena, 2008

\chapter{Úvod}
V oblasti robotiky je velmi důležíté mít možnost vytvářet rychle a levně prototypy.
K tomuto účelu je při návrhu fyzické struktury robota výhodné použít počítačové modely a simulace.
Je výhodné mít i možnost rychle prototypovat řízení robota.
Řízení robota je ovšem možné realizovat mnoha způsoby, např. umělými neuronovými sítěmi, konenčnými automaty nebo i programy v nějakém imperativním jazyce.
V závislosti na vybrané metodě řízení robota jsou k dispozici různé alogritmy a automatizované nástroje pro nalezení konfigurace zvoleného způsobu řízení, která bude mít za následek požadované chování robota.
Touto konfigurací může být např. váhy neuronové sítě, definice konečného automatu nebo sekvence příkazů imperativního jazyka.
Právě řízením robota programy napsanými v imperativním jazyce (byť jednoduchém) se zabývá tato práce, ve které jsou použity evoluční algoritmy pro automatizované hledání vhodného řízení robota.

Cílem této práce je návrh a implementace nástroje pro automatizované hledání vhodného kontroléru robotického modelu pro průchod prostorem po dané trajektorii.
Pro návrh vhodného programu je použita technika zjednodušeného Lineárního Genetického Programování.
Pro simulaci pohybu robotického modelu byl použit simulátor Mujoco.
Účinnost softwarového řízení je experimentálně doložena.

\chapter{Evoluční algoritmy}
Evoluční algoritmy (EA) jsou inspirovány přírodními evolučními procesy a Darwinovou teorií evoluce.
EA se využívají ke stochastickému prohledávání stavového prostoru.
EA, narozdíl od jiných metod, pracují s celou populací kandidátních řešení (jedinců), které se vyvíjí paralelně.
Každý jedinec v populaci v sobě nese zakódovanou informaci o konktrétním řešení, kterou nazýváme genotyp.
Tato informace se pomocí růstové funkce převádí na fenotyp, který už reprezentuje řešení daného problému.

Myšlenku EA můžeme popsat následovně.
Máme populaci jedinců, kteří jsou všichni umístěni ve společném prostředí, ve kterém soutěží o zdroje.
To má za následek přirozený výběr jedinců, který se projevuje tak, že horší jedinci mají menší pravděpodobnost reprodukce, než-li ti lepší.
Tímto se přirozeně zvyšuje kvalita populace.
Reprodukce probíhá dvojím způsobem, a to křížením a mutací.
Křížení pracuje se dvěmi rodiči a má za následek vytvoření dvou potomků, kteří vznikají kombinací genotypu obou rodičů.
Mutace pracuje nad jedním rodičem a produkuje jednoho potomka, který má narozdíl od svého ročiče lehce pozměněný genotyp.

EA v sobě zahrnují dva procesy.
Prvním z nich jsou variační operátory (rekombinace, mutace), které do populace přináší potřebnou různorodost a tak zajišťují prohledávání nových možných řešení.
Druhý z nich je operátor selekce, který vybírá častěji lepší řešení a tak zlepšuje průměrnou kvalitu populace.

Činnost obecného EA můžeme vidět na algoritmu 1:
todo: pridat algoritmus klasickeho EA

V této práci se používá přístup inspirovaný LGP, které si stručně popíšeme dále.

LGP je varianta GP, která vyvíjí programy složené z instrukcí imperativního jazyka nebo strojového kódu, narozdíl od výrazů funkcionálního jazyka.
Instrukce mají parametry, kterými mohou být buď konstanty nebo proměnné, které se nazývají registry.
Tyto registry dělíme na vstupní, výstupní, pracovní a registry, obsahující konstanty.

Program v LGP v průběhu svého vykonávání čte hodnoty z registrů a modifikuje je za použití instrukcí.
Tímto provádí transformaci hodnot ze vstupních registrů do výstupních registrů.

LGP zahrnuje koncepty pro větvení, iteraci a vytváření podprogramů.
Tyto koncepty ale nejsou v této práci využity.
Namísto toho se z LGP využívá základní myšlenka lineární struktury programu složeného z instrukci a práce s registry.




\chapter{Zkoumání pohyblivých objektů}
\todo{3. Zkoumani pohyblivych objektu (zakladni myslenky shrnte s inspiraci v
clancich G. Hornbyho. ~3 strany. Zamerte se v zaverecne podsekci na
popis objektu, ktere budete mit v BP.}
\todo{precist clanek o evolucni robotice, hlavni myslenky prenest zde a vymezit tuto praci, ze tam uplne napatri, ale patri spise do AI - cca 1 strana?}



Tato práce a pohyblivé struktury, se kterými se pracuje, je inspirována dizertací G. Hornbyho.
G. Hornby ve své práci využíval generativné reprezentace pro development struktury i kontroléru robotů.
[todo obrazky nekterych robotu hornbyho ]
Kotroléry byly realizovány pomocí oscilátorů nebo neuronových sítí.

Wolff a Wahde použili LGP pro návrh kontroléru modelu humanoidního robota, který měl v simulovaném prostředí chodit a následovat zvukové signály.

[todo: overit ] Wolff a Wahle použili LGP s čísly s plovoucí řádovou čárkou, aritmetické, matematický instrukce a větvení.
[todo: overit ] Jejich kontrolér měl informace o natočení všech kloubů modelu a na základě těchto informací programy řídily model robota.




Níže si popíšeme dva modely robotů, se kterými byly provedeny experimenty.
První model, zvaný trojnožka, je vidět na obrázku XXX.
Robot má 3 nohy, každá z nich je spojena s jádrem robota kloubem, který se otáčí v jedné ose.
Rozsah pohybu těchto kloubů je omezen na 50 stupňů.
Model robota má v horní části v místě kloubů umístěny kontaktní body.
Tyto body slouží k detekci převrácení robota (kolizi ze zemí).

%\caption{
Model robota zvaný trojnožka.
Tento model je složen z jádra robota (modře) a 3 nohou (hnědě).
Každá z nohou je s jádrem spojena kloubem, který se otáčí pouze v jedné ose a je umístěn pod fialovou koulí.
Tyto fialové koule slouží k detekci převrácení robota.
Ve středu robota je bod zvaný hlava (červeně).
%}

Druhý robot, zvaný mravenec, je vidět na obrázku XXX.
Robot má 3 páry nohou, které jsou všechny připojeny k tělu robota.
Rozsah pohybu kloubů, které rotují kolem horizontální osy a spojují tělo robota s jeho nohou, je omezen na 100 stupňů.
Rozsah kloubů, které rotují kolem svislé osy a spojují dvě části nohy, je omezen na 65 stupňů.
Robot má v přední části kontaktní bod, taktéž pro zjišťování kolizí se zemí.

%\caption{
Model robota zvaný mravenec.
Tento model je složen z těla robota (modře) a 6-ti nohou (hnědě).
V přední části robota je bod zvaný hlava (červeně).
Každá noha je složena ze dvou pevných částí a jedoho kloubu.
Tento kloub se pohybuje pouze ve svislé ose, tj. může zvedat a snižovat robota.
Celá noha je připojena k tělu robota kloubem, který se pohybuje horizontálně, tj. slouží k odrážení.
%}

\chapter{Evoluční návrh pohyblivých objektů}
\todo{4. Evolucni navrh pohyblivych objektu - HLAVNI KAPITOLA BP - zde
popisteje podrobne vlastni techniky, ktere pro EVOLUCI pouzivate. Fakta
o EA budou vychazet k kapitoly 2.}


Cpp cast
- popis interpretu
- popis jazyka
- podprogramy
- input hodnoty (koste)
- prevod outputu na silu v kloubech ??
- spojeni interpretu a simulatoru
- pocitani fitness!

php cast
- popis evoluce
- algoritmus
- genotyp
- instance EA - populace, delka, selekce, crossover, mutace

spojeni php a cpp

\section{Simulace}

V simulátoru Mujoco je vytvořena scéna, která obsahuje model robota a množinu referenčních bodů, které svým pořadím a umístěním ve scéně definují trajektorii, kterou má robot následovat.


\section{Interpret}

Program, který řídí model robota, je vykonáván v interpretu.
Interpret obsahuje paměťová místa, kterým se říká registry, které se dělí na: vstupní, výstupní a konstantní.
Každý registr je indetifikovaný unikátním číslem, které se navýzá index, a může obsahovat celočíselné hodnoty v rozsahu od -5 do 5.
Počty registrů jsou následující: 11 konstatních registrů s hodnotami od -5 do 5, 2 vstupní registry, a 3 nebo 12 výstupních registrů (pro každý kloub modelu jeden registr).
Interpret vykonává program, který je složen z instrukcí.

Je zde použit jen jeden druh instrukce, a to instukce s názvem COPY.
Tato instrukce má 2 parametry: zdrojový registr a cílový registr.
Výsledkem této instrukce je zkopírování hodnoty ze vstupního, nebo konstatního, registru do výstupního registru.

\section{Vykonávání programu}

V průběhu simulace je vykonáván program, který čte hodnoty ze vstupních registrů, které obsahují informaci o směru k dalšímu referenčnímu bodu, a zapisuje hodnoty do výstupních registrů, které se převádí na sílu, která je aplikována v jednotlivých kloubech.

\section{Podprogramy}

Každý program, který reprezentuje kandidátní řešení, je pro vykonávání v průběhu simulace rozdělen na 3 podprogramy.
Tyto podprogramy se nazývají init, main a event.

Podprogram init se vykoná pouze na začátku simulace a všechny instrukce jsou provedeny v nulovém čase a poté je po 1 sekundě spuštěn podprogram main.
Účelem podprogramu init je nastavení počátečního natočení kloubů modelu.

Podprogram main je v průběhu simulace vykonáván v nekonečné smyčce.
Instrukce v tomto podprogramu se nevykonají všechny v nulovém čase, ale vyonávají se s periodou 0.3 sekundy.
Jedná se o nejdelší a nejdůležitější podprogram.

Podprogram event se vykoná v situaci, kdy se model přiblíží do určené vzdálenosti od referenčního bodu, avšak pro každý referenční bod pouze jednou.
Stejně jako u podprogramu init jsou instrukce provedeny v nulovém čase a poté je po 1 sekundě spuštěn podprogram main.
Účelem podprogramu event je změna natočení kloubů modelu jako příprava k pohybu k následujícímu referečnímu bodu.

\section{Input hodnoty}

Hodnoty, které se ukládájí do vstupních registrů, vychází z informace o směru k následujícímu referenčnímu bodu.
Informace o směru je opět vyjádřena číslem od -5 do 5 a vypočítává se následujícím mechanismem.

Prostor kolem modelu je rozdělen na několik kruhových výsečí, kde každá výseč je ohodnocena číslem od -5 do 5, viz obr. KOŠTĚ.
Informace o směru je rovna ohodnocení výseče, ve které se nachází další referenční bod.
Tato informace je v nezměněné podobě vložena do prvního vstupního registru.
Do druhého registru je vložena hodnota s převráceným znaménkem.

Na obrázku KOŠTĚ můžeme vidět situaci, kdy model (na obrázku dole) směřuje směrem nahoru a další referenční bod (modře) se nachází ve výseči ohodnocené číslem 2.
Hodnoty vstupních registrů budou tedy čísla 2 a -2.

\section{Výstupní registry}

Každý z výstupních registrů interpretu odpovídá jednomu kloubu modelu.
Hodnoty z výstupního registru jsou z interpretu čteny a převádí se na ovládací signály, které se předávají simulátoru.
Hodnota (ovládací signál) v sobě obsahuje dvě informace.
První z nich je dána znaménkem a určuje, kterým směrem bude aplikována síla v kloubu.
Druhá informace je dána velikostí hodnoty a určuje velikost této síly.

\section{Simulátor}
Simulátor Mujoco funguje jako TODOOOO dynamicky linkovana knihovna napsana v jazyce C.
Tato knihovna poskytuje řadu funkcí, které umožňují řídít běh simulace.
V uživatelkém programu je tedy nutné z poskytnutých funkcí sestavit algoritmus spojité simulace (ukázkové uživtelské programy jsou součástí distribuce).
Uživatel má plnou kontrolu nad během simulace, a to tím, že volá knihovní funkci TODOO mj\_step(), která v simulaci pokročí definovaným časem.
Ve smyčce algoritmu spojité simulace jsou vloženy funkce, které ze simulátory čtou pozice jendotlivých obejktů, běh interpretu, výpočet fitness funkce a mapování výstupních hodnot z interpretu na ovládací signály.
Ve zjednodušené formě je program znázorněn na OBRÁZKU.






4.1 Evoluce programu
Pro vyse uvedene case studies doporucuji provest experimenty vzdy s
trojnozkou a mravencem na spirale.


\chapter{Závěr}
Závěrečná kapitola obsahuje zhodnocení dosažených výsledků se zvlášť vyznačeným vlastním přínosem studenta. Povinně se zde objeví i zhodnocení z pohledu dalšího vývoje projektu, student uvede náměty vycházející ze zkušeností s řešeným projektem a uvede rovněž návaznosti na právě dokončené projekty.

%=========================================================================
